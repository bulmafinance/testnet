{
  "language": "Solidity",
  "sources": {
    "src/solver/Solver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"./interface/ISolver.sol\";\r\n\r\ncontract Solver is ISolver, Initializable {\r\n    address public _admin;\r\n    address public pendingAdmin;\r\n\r\n    mapping(address => bool) public transferGuardianPaused;\r\n    mapping(address => bool) public depositGuardianPaused;\r\n    mapping(address => bool) public withdrawGuardianPaused;\r\n\r\n    mapping(address => bool) public convertUnsafeTransferContracts;\r\n    mapping(address => bool) public rejectUnsafeTransferContracts;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == _admin, \"only admin\");\r\n        _;\r\n    }\r\n\r\n    function initialize() public initializer {\r\n        _admin = msg.sender;\r\n    }\r\n\r\n    function isSolver() external pure override returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function _setTransferGuuardianPause(address product, bool enable)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        transferGuardianPaused[product] = enable;\r\n    }\r\n\r\n    function _setDepositGuuardianPause(address product, bool enable)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        depositGuardianPaused[product] = enable;\r\n    }\r\n\r\n    function _setWithdrawGuuardianPause(address product, bool enable)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        withdrawGuardianPaused[product] = enable;\r\n    }\r\n\r\n    function _setConvertUnsafeTransferContracts(address product, bool enable)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        convertUnsafeTransferContracts[product] = enable;\r\n    }\r\n\r\n    function _setRejectUnsafeTransferContracts(address product, bool enable)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        rejectUnsafeTransferContracts[product] = enable;\r\n    }\r\n\r\n    function depositAllowed(\r\n        address product,\r\n        address depositor,\r\n        uint64 term,\r\n        uint256 depositAmount,\r\n        uint64[] calldata maturities\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        depositor;\r\n        term;\r\n        depositAmount;\r\n        maturities;\r\n\r\n        require(!depositGuardianPaused[product], \"deposit is paused\");\r\n\r\n        return 0;\r\n    }\r\n\r\n    function depositVerify(\r\n        address product,\r\n        address depositor,\r\n        uint256 depositAmount,\r\n        uint256 tokenId,\r\n        uint64 term,\r\n        uint64[] calldata maturities\r\n    ) external override returns (uint256) {\r\n        product;\r\n        depositor;\r\n        depositAmount;\r\n        tokenId;\r\n        term;\r\n        maturities;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function withdrawAllowed(\r\n        address product,\r\n        address payee,\r\n        uint256 withdrawAmount,\r\n        uint256 tokenId,\r\n        uint64 term,\r\n        uint64 maturity\r\n    ) external override returns (uint256) {\r\n        //reserve\r\n        product;\r\n        payee;\r\n        withdrawAmount;\r\n        tokenId;\r\n        term;\r\n        maturity;\r\n\r\n        require(!withdrawGuardianPaused[product], \"withdraw is paused\");\r\n\r\n        return 0;\r\n    }\r\n\r\n    function withdrawVerify(\r\n        address product,\r\n        address payee,\r\n        uint256 withdrawAmount,\r\n        uint256 tokenId,\r\n        uint64 term,\r\n        uint64 maturity\r\n    ) external override returns (uint256) {\r\n        //reserve\r\n        product;\r\n        payee;\r\n        withdrawAmount;\r\n        tokenId;\r\n        term;\r\n        maturity;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function transferFromAllowed(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        from;\r\n        to;\r\n        tokenId;\r\n        amount;\r\n        targetTokenId;\r\n\r\n        require(!transferGuardianPaused[product], \"transfer is paused\");\r\n        return 0;\r\n    }\r\n\r\n    function transferFromVerify(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        from;\r\n        to;\r\n        tokenId;\r\n        targetTokenId;\r\n        amount;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function mergeAllowed(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        owner;\r\n        tokenId;\r\n        targetTokenId;\r\n        amount;\r\n        return 0;\r\n    }\r\n\r\n    function mergeVerify(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        owner;\r\n        tokenId;\r\n        targetTokenId;\r\n        amount;\r\n        return 0;\r\n    }\r\n\r\n    function splitAllowed(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 newTokenId,\r\n        uint256 amount\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        owner;\r\n        tokenId;\r\n        newTokenId;\r\n        amount;\r\n        return 0;\r\n    }\r\n\r\n    function splitVerify(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 newTokenId,\r\n        uint256 amount\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        product;\r\n        owner;\r\n        tokenId;\r\n        newTokenId;\r\n        amount;\r\n        return 0;\r\n    }\r\n\r\n    function publishFixedPriceAllowed(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address currency,\r\n        uint256 min,\r\n        uint256 max,\r\n        uint256 startTime,\r\n        bool useAllowList,\r\n        uint256 price\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        icToken;\r\n        tokenId;\r\n        seller;\r\n        currency;\r\n        min;\r\n        max;\r\n        startTime;\r\n        useAllowList;\r\n        price;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function publishDecliningPriceAllowed(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address currency,\r\n        uint256 min,\r\n        uint256 max,\r\n        uint256 startTime,\r\n        bool useAllowList,\r\n        uint256 highest,\r\n        uint256 lowest,\r\n        uint256 duration,\r\n        uint256 interval\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        icToken;\r\n        tokenId;\r\n        seller;\r\n        currency;\r\n        min;\r\n        max;\r\n        startTime;\r\n        useAllowList;\r\n        highest;\r\n        lowest;\r\n        duration;\r\n        interval;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function publishVerify(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address currency,\r\n        uint256 saleId,\r\n        uint256 units\r\n    ) external override {\r\n        //reserve vars\r\n        icToken;\r\n        tokenId;\r\n        seller;\r\n        currency;\r\n        saleId;\r\n        units;\r\n    }\r\n\r\n    function buyAllowed(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        uint256 saleId,\r\n        address buyer,\r\n        address currency,\r\n        uint256 buyAmount,\r\n        uint256 buyUnits,\r\n        uint256 price\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        icToken;\r\n        tokenId;\r\n        saleId;\r\n        buyer;\r\n        currency;\r\n        buyAmount;\r\n        buyUnits;\r\n        price;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function buyVerify(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        uint256 saleId,\r\n        address buyer,\r\n        address seller,\r\n        uint256 amount,\r\n        uint256 units,\r\n        uint256 price,\r\n        uint256 fee\r\n    ) external override {\r\n        //reserve\r\n        icToken;\r\n        tokenId;\r\n        saleId;\r\n        buyer;\r\n        seller;\r\n        amount;\r\n        units;\r\n        price;\r\n        fee;\r\n    }\r\n\r\n    function removeAllow(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        uint256 saleId,\r\n        address seller\r\n    ) external override returns (uint256) {\r\n        //reserve vars\r\n        icToken;\r\n        tokenId;\r\n        saleId;\r\n        seller;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function needConvertUnsafeTransfer(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 units\r\n    ) public view override returns (bool) {\r\n        //reserve vars\r\n        product;\r\n        from;\r\n        tokenId;\r\n        units;\r\n        return convertUnsafeTransferContracts[to];\r\n    }\r\n\r\n    function needRejectUnsafeTransfer(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 units\r\n    ) public view override returns (bool) {\r\n        //reserve vars\r\n        product;\r\n        from;\r\n        tokenId;\r\n        units;\r\n        return rejectUnsafeTransferContracts[to];\r\n    }\r\n\r\n    function _setPendingAdmin(address newPendingAdmin) public {\r\n        require(msg.sender == _admin, \"only admin\");\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n    }\r\n\r\n    function _acceptAdmin() public {\r\n        require(\r\n            msg.sender == pendingAdmin && msg.sender != address(0),\r\n            \"only pending admin\"\r\n        );\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = _admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        _admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, _admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "src/solver/interface/ISolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface ISolver {\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    function isSolver() external returns (bool);\r\n\r\n    function depositAllowed(\r\n        address product,\r\n        address depositor,\r\n        uint64 term,\r\n        uint256 depositAmount,\r\n        uint64[] calldata maturities\r\n    ) external returns (uint256);\r\n\r\n    function depositVerify(\r\n        address product,\r\n        address depositor,\r\n        uint256 depositAmount,\r\n        uint256 tokenId,\r\n        uint64 term,\r\n        uint64[] calldata maturities\r\n    ) external returns (uint256);\r\n\r\n    function withdrawAllowed(\r\n        address product,\r\n        address payee,\r\n        uint256 withdrawAmount,\r\n        uint256 tokenId,\r\n        uint64 term,\r\n        uint64 maturity\r\n    ) external returns (uint256);\r\n\r\n    function withdrawVerify(\r\n        address product,\r\n        address payee,\r\n        uint256 withdrawAmount,\r\n        uint256 tokenId,\r\n        uint64 term,\r\n        uint64 maturity\r\n    ) external returns (uint256);\r\n\r\n    function transferFromAllowed(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function transferFromVerify(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function mergeAllowed(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function mergeVerify(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 targetTokenId,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function splitAllowed(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 newTokenId,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function splitVerify(\r\n        address product,\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 newTokenId,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function needConvertUnsafeTransfer(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 units\r\n    ) external view returns (bool);\r\n\r\n    function needRejectUnsafeTransfer(\r\n        address product,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 units\r\n    ) external view returns (bool);\r\n\r\n    function publishFixedPriceAllowed(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address currency,\r\n        uint256 min,\r\n        uint256 max,\r\n        uint256 startTime,\r\n        bool useAllowList,\r\n        uint256 price\r\n    ) external returns (uint256);\r\n\r\n    function publishDecliningPriceAllowed(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address currency,\r\n        uint256 min,\r\n        uint256 max,\r\n        uint256 startTime,\r\n        bool useAllowList,\r\n        uint256 highest,\r\n        uint256 lowest,\r\n        uint256 duration,\r\n        uint256 interval\r\n    ) external returns (uint256);\r\n\r\n    function publishVerify(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address currency,\r\n        uint256 saleId,\r\n        uint256 units\r\n    ) external;\r\n\r\n    function buyAllowed(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        uint256 saleId,\r\n        address buyer,\r\n        address currency,\r\n        uint256 buyAmount,\r\n        uint256 buyUnits,\r\n        uint256 price\r\n    ) external returns (uint256);\r\n\r\n    function buyVerify(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        uint256 saleId,\r\n        address buyer,\r\n        address seller,\r\n        uint256 amount,\r\n        uint256 units,\r\n        uint256 price,\r\n        uint256 fee\r\n    ) external;\r\n\r\n    function removeAllow(\r\n        address icToken,\r\n        uint256 tokenId,\r\n        uint256 saleId,\r\n        address seller\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}